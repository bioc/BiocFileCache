#' @import methods
#' @import httr
#' @import rappdirs
.BiocFileCacheBase = setClass(
    "BiocFileCacheBase",
    slots=c(cache="character")
)

.BiocFileCacheReadOnly = setClass(
    "BiocFileCacheReadOnly",
    contains="BiocFileCacheBase",
    slots=c(rid="character")
)

.BiocFileCache = setClass(
    "BiocFileCache",
    contains="BiocFileCacheBase"
)

#' BiocFileCache class
#'
#' This class represents the location of files stored on disk. Use the
#' return value to add and retrieve files that persist across
#' sessions.
#'
#' @details The package defines 'BiocFileCache', 'BiocFileCacheBase' and
#' 'BiocFileCacheReadOnly' classes.
#'
#' Slots unique to 'BiocFileCache' and  related classes:
#' \itemize{
#'   \item{'cache': }{character(1), Describes the On-disk location
#'     (directory path) of the cache}
#'   \item{'rid': }{character(), List of the unique rids in the cache. }
#' }
#'
#' The cache creates an RSQLite database to keep track of local and remote
#' resources. Each item located in the database will have the following
#' information:
#' \itemize{
#'   \item{'rid': }{resource id. Autogenerated. This is a unique identifier
#'     automatically generated when a resource is added to the cache}
#'   \item{'rname': }{resource name. This is given by the user when a
#'     resource is added to the cache. It does not have to be unique
#'     and can be updated at anytime. We recommend descriptive key
#'     words and identifers.}
#'   \item{'create_time': }{The date and time a resource is added to the cache.}
#'   \item{'access_time': }{The date and time a resource is utilized
#'     within the cache. The access time is updated when the resource
#'     is updated or accessed}
#'   \item{'rpath': }{resource path. This is the path to the local
#'     (on-disk) file}
#'   \item{'rtype': }{resource type. Either "relative", "local", or
#'     "web", indicating if the resource has a remote origin}
#'   \item{'fpath': }{If rtype is "web", this is the link to the
#'     remote resource. It will be utilized to download or update the
#'     remote data}
#'   \item{'last_modified_time': }{For a remote resource, the
#'     last_modified (if available) information for the local copy of
#'     the data. This information is checked against the remote
#'     resource to determine if the local copy is stale and needs to
#'     be updated}
#' }
#'
#' @param cache character(1) On-disk location (directory path) of
#'     cache. For default location see \code{\link[rappdirs]{user_cache_dir}}.
#' @return For 'BiocFileCache': a \code{BiocFileCache} instance.
#' @examples
#' # bfc <- BiocFileCache()            # global cache
#' # bfc
#' bfc0 <- BiocFileCache(tempfile())         # temporary catch for examples
#' @name BiocFileCache-class
#' @aliases BiocFileCache
#' @export BiocFileCache
BiocFileCache <-
    function(cache=user_cache_dir(appname="BiocFileCache"))
{
    stopifnot(is.character(cache), length(cache) == 1L, !is.na(cache))

    if (!file.exists(cache))
        dir.create(cache)
    bfc <- .BiocFileCache(cache=cache)
    .sql_create_db(bfc)
    bfc
}

#' @export
setGeneric("bfccache", function(x) standardGeneric("bfccache"))

#' @describeIn BiocFileCache Get the location of the on-disk cache.
#' @param x A \code{BiocFileCache} instance.
#' @return For 'bfccache': character(1) location of the directory
#'     containing the cache.
#' @examples
#' bfccache(bfc0)
#' @aliases bfccache
#' @exportMethod bfccache
setMethod("bfccache", "BiocFileCacheBase", function(x) x@cache)

#' @describeIn BiocFileCache Get the number of objects in the file
#'     cache.
#' @return For 'length': integer(1) Number of objects in the file
#'     cache.
#' @examples
#' length(bfc0)
#' @importFrom stats setNames
#' @exportMethod length
setMethod("length", "BiocFileCacheBase", function(x) length(bfcrid(x)))

#' @rdname BiocFileCache-class
#' @aliases bfcrid
#' @export
setGeneric("bfcrid", function(x) standardGeneric("bfcrid"))

#' @describeIn BiocFileCache Get the rids of the object.
#' @aliases bfcrid,BiocFileCacheReadOnly-method
#' @exportMethod bfcrid
setMethod("bfcrid", "BiocFileCacheReadOnly", function(x) x@rid)

#' @rdname BiocFileCache-class
#' @aliases bfcrid,BiocFileCache-method
#' @exportMethod bfcrid
setMethod("bfcrid", "BiocFileCache", function(x) .get_all_rids(x))

#' @describeIn BiocFileCache Subset a BiocFileCache object.
#' @param drop Ignored.
#' @return For '[': A subset of the BiocFileCache object.
#' @exportMethod [
setMethod("[", c("BiocFileCache", "character", "missing"),
    function(x, i, j, ..., drop=TRUE)
{
    stopifnot(all(i %in% bfcrid(x)))
    stopifnot(identical(drop, TRUE))

    .BiocFileCacheReadOnly(x, rid=as.character(i))
})

#' @rdname BiocFileCache-class
#' @aliases [,BiocFileCacheReadOnly,character,missing-method
#' @exportMethod [
setMethod("[", c("BiocFileCacheReadOnly", "character", "missing"),
    function(x, i, j, ..., drop=TRUE)
{
    stopifnot(all(i %in% bfcrid(x)))
    stopifnot(identical(drop, TRUE))

    initialize(x, rid=as.character(i))
})

#' @rdname BiocFileCache-class
#' @aliases [,BiocFileCache,missing,missing-method
#' @exportMethod [
setMethod("[", c("BiocFileCache", "missing", "missing"),
    function(x, i, j, ..., drop=TRUE)
{
    stopifnot(identical(drop, TRUE))

    .BiocFileCacheReadOnly(x, rid=bfcrid(x))
})

#' @rdname BiocFileCache-class
#' @aliases [,BiocFileCacheReadOnly,missing,missing-method
#' @exportMethod [
setMethod("[", c("BiocFileCacheReadOnly", "missing", "missing"),
    function(x, i, j, ..., drop=TRUE)
{
    x                                   # no-op
})

#' @describeIn BiocFileCache Get a file path for select resources from
#'     the cache.
#' @param i character() 'rid' identifiers.
#' @param j Ignored.
#' @return For '[[': named character(1) rpath for the given resource
#'     in the cache.
#' @exportMethod [[
setMethod("[[", c("BiocFileCacheBase", "character", "missing"),
    function(x, i, j)
{
    stopifnot(length(i) == 1L, i %in% bfcrid(x))

    .sql_update_time(x, i)
    .sql_get_rpath(x, i)
})

#' @describeIn BiocFileCache Set the file path of selected resources
#'     from the cache.
#' @param value character(1) Replacement file path.
#' @return For '[[<-': Updated BiocFileCache, invisibly.
#' @exportMethod [[<-
setReplaceMethod("[[", c("BiocFileCache", "character", "missing", "character"),
    function(x, i, j, ..., value)
{
    stopifnot(length(i) == 1L, length(value) == 1L)
    stopifnot(file.exists(value))

    .sql_update_time(x, i)
    .sql_set_rpath(x, i, value)
    if (identical(.sql_get_rtype(x, i), "relative")) {
        warning("updating rpath, changing rtype to 'local'")
        .sql_set_rtype(x, i, "local")
    }
    x
})

#' @export
setGeneric("bfcnew",
    function(x, rname, rtype=c("relative", "local"), ext=NA_character_)
    standardGeneric("bfcnew"),
    signature="x"
)

#' @describeIn BiocFileCache Add a resource to the database
#' @param rname character(1) Name of object in file cache. For
#'     'bfcupdate' a character vector of replacement rnames.
#' @param ext character(1) A file extension to add to the local
#'     copy of the file (e.g., \sQuote{sqlite}, \sQuote{txt},
#'     \sQuote{tar.gz}).
#' @return For 'bfcnew': named character(1), the path to save your
#'     object / file.  The name of the return value is the unique rid
#'     for the resource.
#' @examples
#' path <- bfcnew(bfc0, "NewResource")
#' path
#' @aliases bfcnew
#' @exportMethod bfcnew
setMethod("bfcnew", "BiocFileCache",
    function(x, rname, rtype=c("relative", "local"), ext=NA_character_)
{
    stopifnot(length(rname) == 1L, is.character(rname), !is.na(rname))
    stopifnot(length(ext) == 1L, is.character(ext))
    rtype <- match.arg(rtype)

    rid <- .sql_new_resource(x, rname, rtype, NA_character_, ext)
    rpath <- .sql_get_rpath(x, rid)
    setNames(rpath, rid)
})

#' @export
setGeneric("bfcadd",
    function(
        x, rname, fpath = rname, rtype=c("auto", "relative", "local", "web"),
        action=c("copy", "move", "asis"), proxy="", ...
    ) standardGeneric("bfcadd"),
    signature="x"
)

#' @describeIn BiocFileCache Add an existing resource to the database
#' @param fpath For bfcadd(), character(1) path to current file
#'     location or remote web resource. If none is given, the rname is
#'     assumed to also be the path location. For bfcupdate()
#'     character() vector of replacement web resources.
#' @param rtype character(1) 'local', 'relative', or 'web' indicating
#'     if the resource is a local file, a relative path in the cache,
#'     or a web resource. For \code{bfcnew}: local or relative are
#'     only options. For \code{bfcadd}, the default 'auto' creates
#'     relative or web paths, based on the path prefix.
#' @param action character(1) How to handle the file: create a
#'     \code{copy} of \code{fpath} in the cache directory; \code{move}
#'     the file to the cache directory; or \code{asis} leave the file
#'     in current location but save the path in the cache. If 'rtype
#'     == "relative"', action can not be "asis".
#' @param proxy character(1) (Optional) proxy server.
#' @param ... For 'bfcadd': For \code{action="copy"}, additional
#'     arguments passed to \code{file.copy}. For 'bfcrpaths':
#'     Additional arguments passed to 'bfcadd'.
#' @return For 'bfcadd': named character(1), the path to save your
#'     object / file.  The name of the character is the unique rid for
#'     the resource.
#' @examples
#' fl1 <- tempfile(); file.create(fl1)
#' bfcadd(bfc0, "Test1", fl1)                 # copy
#' fl2 <- tempfile(); file.create(fl2)
#' bfcadd(bfc0, "Test2", fl2, action="move")         # move
#' fl3 <- tempfile(); file.create(fl3)
#' add3 <- bfcadd(bfc0, "Test3", fl3, rtype="local", action="asis")  # reference
#' rid3 <- names(add3)
#'
#' bfc0
#' file.exists(fl1)                                # TRUE
#' file.exists(fl2)                                # FALSE
#' file.exists(fl3)                                # TRUE
#'
#' # add a remote resource
#' url <- "http://httpbin.org/get"
#' bfcadd(bfc0, "TestWeb", fpath=url)
#' @aliases bfcadd
#' @exportMethod bfcadd
setMethod("bfcadd", "BiocFileCache",
    function(
        x, rname, fpath = rname, rtype = c("auto", "relative", "local", "web"),
        action=c("copy", "move", "asis"), proxy="", ...)
{
    stopifnot(is.character(rname), length(rname) == 1L, !is.na(rname))
    stopifnot(is.character(fpath), length(fpath) == 1L, !is.na(fpath))
    action <- match.arg(action)
    rtype <- match.arg(rtype)
    rtype <- .util_standardize_rtype(rtype, fpath, action)
    stopifnot(rtype == "web" || file.exists(fpath))
    stopifnot(is.character(proxy), length(proxy) == 1L, !is.na(proxy))

    rid <- .sql_new_resource(x, rname, rtype, fpath)
    rpath <- bfcrpath(x, rids = rid)
    if (rtype %in% c("local", "relative")) {
        switch(
            action,
            copy = file.copy(fpath, rpath, ...),
            move = file.rename(fpath, rpath),
            asis = {
                .sql_set_rpath(x, rid, fpath)
                rpath <- bfcrpath(x, rids = rid)
            }
        )
    } else {                            # rtype == "web"
        .util_download(x, rid, proxy, "bfcadd()")
    }

    setNames(rpath, rid)
})

#' @export
setGeneric("bfcinfo",
    function(x, rids) standardGeneric("bfcinfo"),
    signature="x"
)

#' @describeIn BiocFileCache list resources in database
#' @param rids character() Vector of rids.
#' @return For 'bfcinfo': A \code{bfc_tbl} of current resources in the
#'     database.
#' @examples
#' bfcinfo(bfc0)
#' @aliases bfcinfo
#' @exportMethod bfcinfo
setMethod("bfcinfo", "BiocFileCacheBase",
    function(x, rids)
{
    if (missing(rids))
        rids <- bfcrid(x)
    stopifnot(all(rids %in% bfcrid(x)))

    .sql_get_resource_table(x, rids)
})

setOldClass("tbl_bfc")

#' @describeIn BiocFileCache Get the rids of the object
#' @exportMethod bfcrid
setMethod("bfcrid", "tbl_bfc", function(x) .get_tbl_rid(x))

#' @export
setGeneric("bfcpath", function(x, rid) standardGeneric("bfcpath"))

#' @describeIn BiocFileCache display paths of resource
#' @param rid character(1) Unique resource id.
#' @return For 'bfcpath': the file path location to load and original
#'     source information for web resources.
#' @examples
#' bfcpath(bfc0, rid3)
#' @aliases bfcpath
#' @exportMethod bfcpath
setMethod("bfcpath", "BiocFileCacheBase",
    function(x, rid)
{
    stopifnot(!missing(rid), length(rid) == 1L, rid %in% bfcrid(x))

    .sql_update_time(x, rid)
    path <- .sql_get_rpath(x, rid)
    if (.sql_get_rtype(x, rid) == "web") {
        fpath <- .sql_get_fpath(x, rid)
        setNames(c(path, fpath), c(rid, "fpath"))
    } else {
        setNames(path, rid)
    }
})

#' @export
setGeneric("bfcrpath", function(x, rnames, ..., rids) standardGeneric("bfcrpath"))

#' @describeIn BiocFileCache display rpath of resource. If 'rnames' is
#'     in the cache the path is returned, if it is not it will try to
#'     add it to the cache with 'bfcadd'
#' @param rnames character() list of rnames to search and match on.
#' @return For 'bfcrpath': The local file path location to load.
#' @examples
#' bfcrpath(bfc0, rids = rid3)
#' @aliases bfcrpath
#' @exportMethod bfcrpath
setMethod("bfcrpath", "BiocFileCacheBase",
    function(x, rnames, ..., rids)
{
    if (!missing(rnames) && !missing(rids))
        stop("specify either 'rnames' or 'rids' not both.")

    update_time_and_path <- function(x, i) {
        .sql_update_time(x, i)
        .sql_get_rpath(x, i)
    }

    add_or_return_rname <- function(x, name, ...){
        res <- bfcrid(bfcquery(x, name))
        if (length(res) == 0L){
            tryCatch({
                bfcadd(x, name, ...)
            }, error=function(e) {
                warning(conditionMessage(e))
                NA_character_
            })
        } else if (length(res) == 1L){
            path <- update_time_and_path(x, res)
            setNames(path, res)
        } else {
            warning("rname: '", name ,"' is not unique.")
            NA_character_
        }
    }

    if (missing(rids))
        rids <- bfcrid(x)

    if (!missing(rnames)) {
        rpaths <- vapply(rnames, add_or_return_rname, character(1), x=x, ...)
        if (anyNA(rpaths)) {
            rmdx <- setdiff(bfcrid(x), rids)
            if (length(rmdx) > 0L)
                bfcremove(x, rmdx)
            stop("all 'rnames' not found or valid.")
        }
        setNames(rpaths, .fix_rnames(x, names(rpaths)))
    } else {
        stopifnot(all(rids %in% bfcrid(x)))
        rpaths <- vapply(rids, update_time_and_path, character(1), x = x)
        setNames(rpaths, rids)
    }

})

#' @export
setGeneric("bfcupdate",
    function(x, rids, value, colID, ...) standardGeneric("bfcupdate"),
    signature="x"
)

#' @describeIn BiocFileCache Update a resource in the cache
#' @param rpath character() vector of replacement rpaths.
#' @return For 'bfcupdate': an updated \code{BiocFileCache} object,
#'     invisibly.
#' @examples
#' bfcupdate(bfc0, rid3, rpath=fl3, rname="NewRname")
#' bfc0[[rid3]] = fl1
#' bfcupdate(bfc0, "BFC5", fpath="http://google.com")
#' @aliases bfcupdate
#' @exportMethod bfcupdate
setMethod("bfcupdate", "BiocFileCache",
    function(x, rids, rname=NULL, rpath=NULL, fpath=NULL, proxy="")
{
    stopifnot(!missing(rids), all(rids %in% bfcrid(x)))
    stopifnot(
        is.null(rname) || (length(rids) == length(rname)),
        is.null(rpath) || (length(rids) == length(rpath)),
        is.null(fpath) || (length(rids) == length(fpath))
    )
    stopifnot(
        is.null(rname) || is.character(rname),
        is.null(rpath) || is.character(rpath),
        is.null(fpath) || is.character(fpath)
    )

    for (i in seq_along(rids)) {

        .sql_update_time(x, rids[i])

        if (!is.null(rname)) {
            .sql_set_rname(x, rids[i], rname[i])
        }

        if (!is.null(rpath)) {
            if (!file.exists(rpath[i]))
                stop(
                    "bfcupdate() failed",
                    "\n  rid: ", rids[i],
                    "\n  rpath: ", sQuote(rpath[i]),
                    "\n  reason: rpath does not exist.",
                    call.=FALSE
                )
            .sql_set_rpath(x, rids[i], rpath[i])
            if (.sql_get_rtype(x, rids[i]) == "relative"){
                warning("updating rpath, changing rtype to 'local'")
                .sql_set_rtype(x, rids[i], "local")
            }
        }

        if (!is.null(fpath)) {
            if (.sql_get_rtype(x, rids[i]) != "web")
                stop("bfcupdate() failed",
                    "\n  rid: ", rids[i],
                    "\n  reason: resource rtype is not 'web'",
                    call.=FALSE)

            .util_download_and_rename(
                x, rids[i], proxy, "bfcupdate()", fpath[i]
            )
            .sql_set_fpath(x, rids[i], fpath[i])
        }
    }

    invisible(x)
})

#' @export
setGeneric("bfcquery", function(x, query) standardGeneric("bfcquery"))

#' @describeIn BiocFileCache query resource
#' @param query character() Pattern(s) to match in resource. It will
#'     match the pattern against rname, rpath, and fpath using SQL
#'     \code{LIKE}, using \code{&&} logic across query elements.
#' @return For 'bfcquery': A \code{bfc_tbl} of current resources in
#'     the database whose rname, rpath, or fpath contained query. If
#'     multiple values are given, the resource must contain all of the
#'     patterns. A tbl with zero rows is returned when no resources
#'     match the query.
#' @examples
#' bfcquery(bfc0, "test")
#' @aliases bfcquery
#' @exportMethod bfcquery
setMethod("bfcquery", "BiocFileCacheBase",
    function(x, query)
{
    stopifnot(is.character(query))

    rids <- intersect(.sql_query_resource(x, query), bfcrid(x))
    .sql_get_resource_table(x, rids)
})

#' @export
setGeneric("bfccount", function(x) standardGeneric("bfccount"))

#' @describeIn BiocFileCache Get the number of objects in the file
#'     cache or query.
#' @return For 'bfccount': integer(1) Number of objects in the cache
#'     or query.
#' @examples
#' bfccount(bfc0)
#' bfccount(bfcquery(bfc0, "test"))
#' @aliases bfccount
#' @exportMethod bfccount
setMethod("bfccount", "BiocFileCacheBase",
    function(x)
{
    bfccount(bfcinfo(x))
})

#' @rdname BiocFileCache-class
#' @aliases bfccount,tbl_bfc-method
#' @exportMethod bfccount
setMethod("bfccount", "tbl_bfc",
    function(x)
{
    .sql_get_nrows(x)
})

#' @export
setGeneric("bfcneedsupdate",
    function(x, rids) standardGeneric("bfcneedsupdate")
)

#' @describeIn BiocFileCache check if a resource needs to be updated
#' @return For 'bfcneedsupdate': named logical vector if resource
#'     needs to be updated. The name is the resource
#'     'rid'. \code{TRUE}: fpath \code{modified} time of web resource
#'     more recent than in BiocFileCache; \code{FALSE}: fpath
#'     \code{modified} time of web resource not more recent than in
#'     BiocFileCache; \code{NA}: web resource modified time could not
#'     be determined.
#' @examples
#' bfcneedsupdate(bfc0, "BFC5")
#' @aliases bfcneedsupdate
#' @exportMethod bfcneedsupdate
setMethod("bfcneedsupdate", "BiocFileCacheBase",
    function(x, rids)
{
    if (missing(rids))
        rids <- .get_all_web_rids(x)
    stopifnot(all(rids %in% bfcrid(x)))
    if (!all(rids %in% .get_all_web_rids(x)))
        stop("rids not all web resources")

    helper <- function(x, rid) {
        .sql_update_time(x, rid)
        file_time <- .sql_get_last_modified(x, rid)
        fpath <- .sql_get_fpath(x, rid)
        web_time <- .httr_get_last_modified(fpath)
        if ((length(file_time) == 0L) || (length(web_time) == 0L)) {
            NA
        } else {
            as.Date(web_time) > as.Date(file_time)
        }
    } # end helper
    result <- vapply(rids, helper, logical(1), x=x)

    setNames(result, rids)
})

#' @export
setGeneric("bfcdownload",
    function(x, rid, proxy="") standardGeneric("bfcdownload")
)

#' @describeIn BiocFileCache Redownload resource to location in cache
#' @return For 'bfcdownload': character(1) path to downloaded resource
#'     in cache.
#' @examples
#' bfcdownload(bfc0, "BFC5")
#' @aliases bfcdownload
#' @exportMethod bfcdownload
setMethod("bfcdownload", "BiocFileCache",
    function(x, rid, proxy="")
{
    stopifnot(!missing(rid), length(rid) == 1L)
    stopifnot(.sql_get_rtype(x, rid) == "web")
    stopifnot(rid %in% bfcrid(x))

    .sql_update_time(x, rid)
    .util_download_and_rename(x, rid, proxy, "bfcdownload()")

    setNames(bfcrpath(x, rids=rid), rid)
})

#' @export
setGeneric("bfcremove", function(x, rids) standardGeneric("bfcremove"))

#' @describeIn BiocFileCache Remove a resource to the database.  If
#'     the local file is located in \code{bfccache(x)}, the file will
#'     also be deleted.
#' @return For 'bfcremove': updated BiocFileCache object, invisibly
#' @examples
#' bfcremove(bfc0, rid3)
#' bfcinfo(bfc0)
#' @aliases bfcremove
#' @exportMethod bfcremove
setMethod("bfcremove", "BiocFileCache",
    function(x, rids)
{
    stopifnot(all(rids %in% bfcrid(x)))

    rpaths <- vapply(rids, .sql_get_rpath, character(1), bfc=x)
    cached <- startsWith(rpaths, bfccache(x))

    .sql_remove_resource(x, rids)
    status <- .util_unlink(rpaths[cached])

    invisible(x)
})

#' @export
setGeneric("bfcsync", function(x, verbose=TRUE) standardGeneric("bfcsync"))

#' @describeIn BiocFileCache sync cache and resource.
#' @param verbose logical(1) If descriptive message and list of issues
#'     should be included as output.
#' @return For 'bfcsync': logical(1) indicating whether the cache is
#'     in sync (\code{TRUE}) or not. 'verbose' is TRUE by default, so
#'     descriptive messages will also be included.
#' @examples
#' bfcsync(bfc0)
#' bfcremove(bfc0, "BFC1")
#' bfcsync(bfc0, FALSE)
#' @aliases bfcsync
#' @importFrom utils capture.output
#' @exportMethod bfcsync
setMethod("bfcsync", "BiocFileCache",
    function(x, verbose=TRUE)
{
    stopifnot(is.logical(verbose), length(verbose) == 1L, !is.na(verbose))

    # files not found
    rids <- .get_rid_filenotfound(x)

    # files untracked in cache location
    files <- file.path(bfccache(x), setdiff(dir(bfccache(x)),.CACHE_FILE))
    paths <- .get_all_rpath(x)
    # normalizePath on windows
    # can't across platform - no opt on linux but added hidden on mac
    if (tolower(.Platform$OS.type) == "windows"){
        files = normalizePath(files)
        paths = normalizePath(paths)
    }
    untracked <- setdiff(files, paths)

    test <- (length(rids) == 0L) && (length(untracked) == 0L)
    if (verbose && (length(rids) != 0L)) {
        txt <-
            "The following entries have local files specified but not found.
            Consider updating or removing:"
        tbl <- capture.output(bfcinfo(x, rids))
        message(
            paste(strwrap(txt), collapse="\n"),
            "\n\n", paste(tbl, collapse="\n")
        )
    }
    if (verbose && (length(untracked) != 0L)) {
        txt <-
            "The following entries are in the cache but not being tracked.
            Consider adding to cache with 'bfcadd()':"
        message(
            paste(strwrap(txt, exdent=4), collapse="\n"),
            "\n  ", paste(untracked, collapse="\n  ")
        )
    }

    test
})

#' @export
setGeneric("cleanbfc",
    function(x, days = 120, ask = TRUE) standardGeneric("cleanbfc"),
    signature="x"
)

#' @describeIn BiocFileCache Remove old/unused files in
#'     BiocFileCache. If file to be removed is not in the bfccache
#'     location it will not be deleted.
#' @param days integer(1) Number of days between accessDate and
#'     currentDate; if exceeded entry will be deleted.
#' @param ask logical(1) Prompt if really want to remove cache and
#'     files.
#' @return For 'cleanbfc': updated BiocFileCache, invisibly.
#' @examples
#' \dontrun{cleanbfc(bfc, ask=FALSE)}
#' @aliases cleanbfc
#' @exportMethod cleanbfc
setMethod("cleanbfc", "BiocFileCache",
    function(x, days = 120, ask=TRUE)
{
    stopifnot(is.numeric(days), length(days) == 1L, !is.na(days))
    stopifnot(is.logical(ask), length(ask) == 1L, !is.na(ask))

    rids <- .sql_clean_cache(x, days)
    rpaths <- vapply(rids, .sql_get_rpath, character(1), bfc=x)
    cached <- startsWith(rpaths, bfccache(x))

    if (ask) {
        txt0 <- paste0(" file ", sQuote(rpaths))
        txt <- paste0("Remove id ", sQuote(rids), ifelse(cached, txt0, ""))
        doit <- vapply(txt, .util_ask, logical(1))

        rids <- rids[doit]
        cached <- cached & doit
    }

    .sql_remove_resource(x, rids)
    .util_unlink(rpaths[cached])

    invisible(x)
})

#' @export
setGeneric("removebfc",
    function(x, ask = TRUE) standardGeneric("removebfc"),
    signature="x"
)

#' @describeIn BiocFileCache Completely remove the BiocFileCache
#' @return For 'removebfc': TRUE if successfully removed.
#' @examples
#' \dontrun{removebfc(bfc, ask=FALSE)}
#' @aliases removebfc
#' @exportMethod removebfc
setMethod("removebfc", "BiocFileCache",
    function(x, ask=TRUE)
{
    stopifnot(is.logical(ask), length(ask) == 1L, !is.na(ask))

    txt <- paste("remove cache and", length(x), "resource(s) (y/N): ")
    if (!ask || .util_ask(txt))
        doit <- .util_unlink(bfccache(x), recursive=TRUE)

    doit
})

#' @describeIn BiocFileCache Display a \code{BiocFileCache} instance.
#' @param object A \code{BiocFileCache} instance.
#' @exportMethod show
setMethod("show", "BiocFileCacheBase",
    function(object)
{
    cat("class: ", class(object), "\n",
        "bfccache: ", bfccache(object), "\n",
        "bfccount: ", bfccount(object), "\n",
        "For more information see: bfcinfo() or bfcquery()\n",
        sep="")
})
